#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Apr 20 11:15:28 2015 by generateDS.py version 2.15b.
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(*args, **kwargs):
    if 'parser' not in kwargs:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ismrmrdHeader(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, subjectInformation=None, studyInformation=None, measurementInformation=None, acquisitionSystemInformation=None, experimentalConditions=None, encoding=None, sequenceParameters=None, userParameters=None):
        self.original_tagname_ = None
        self.version = version
        self.subjectInformation = subjectInformation
        self.studyInformation = studyInformation
        self.measurementInformation = measurementInformation
        self.acquisitionSystemInformation = acquisitionSystemInformation
        self.experimentalConditions = experimentalConditions
        if encoding is None:
            self.encoding = []
        else:
            self.encoding = encoding
        self.sequenceParameters = sequenceParameters
        self.userParameters = userParameters
    def factory(*args_, **kwargs_):
        if ismrmrdHeader.subclass:
            return ismrmrdHeader.subclass(*args_, **kwargs_)
        else:
            return ismrmrdHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_subjectInformation(self): return self.subjectInformation
    def set_subjectInformation(self, subjectInformation): self.subjectInformation = subjectInformation
    def get_studyInformation(self): return self.studyInformation
    def set_studyInformation(self, studyInformation): self.studyInformation = studyInformation
    def get_measurementInformation(self): return self.measurementInformation
    def set_measurementInformation(self, measurementInformation): self.measurementInformation = measurementInformation
    def get_acquisitionSystemInformation(self): return self.acquisitionSystemInformation
    def set_acquisitionSystemInformation(self, acquisitionSystemInformation): self.acquisitionSystemInformation = acquisitionSystemInformation
    def get_experimentalConditions(self): return self.experimentalConditions
    def set_experimentalConditions(self, experimentalConditions): self.experimentalConditions = experimentalConditions
    def get_encoding(self): return self.encoding
    def set_encoding(self, encoding): self.encoding = encoding
    def add_encoding(self, value): self.encoding.append(value)
    def insert_encoding_at(self, index, value): self.encoding.insert(index, value)
    def replace_encoding_at(self, index, value): self.encoding[index] = value
    def get_sequenceParameters(self): return self.sequenceParameters
    def set_sequenceParameters(self, sequenceParameters): self.sequenceParameters = sequenceParameters
    def get_userParameters(self): return self.userParameters
    def set_userParameters(self, userParameters): self.userParameters = userParameters
    def hasContent_(self):
        if (
            self.version is not None or
            self.subjectInformation is not None or
            self.studyInformation is not None or
            self.measurementInformation is not None or
            self.acquisitionSystemInformation is not None or
            self.experimentalConditions is not None or
            self.encoding or
            self.sequenceParameters is not None or
            self.userParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ismrmrdHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ismrmrdHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ismrmrdHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ismrmrdHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ismrmrdHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.subjectInformation is not None:
            self.subjectInformation.export(outfile, level, namespace_, name_='subjectInformation', pretty_print=pretty_print)
        if self.studyInformation is not None:
            self.studyInformation.export(outfile, level, namespace_, name_='studyInformation', pretty_print=pretty_print)
        if self.measurementInformation is not None:
            self.measurementInformation.export(outfile, level, namespace_, name_='measurementInformation', pretty_print=pretty_print)
        if self.acquisitionSystemInformation is not None:
            self.acquisitionSystemInformation.export(outfile, level, namespace_, name_='acquisitionSystemInformation', pretty_print=pretty_print)
        if self.experimentalConditions is not None:
            self.experimentalConditions.export(outfile, level, namespace_, name_='experimentalConditions', pretty_print=pretty_print)
        for encoding_ in self.encoding:
            encoding_.export(outfile, level, namespace_, name_='encoding', pretty_print=pretty_print)
        if self.sequenceParameters is not None:
            self.sequenceParameters.export(outfile, level, namespace_, name_='sequenceParameters', pretty_print=pretty_print)
        if self.userParameters is not None:
            self.userParameters.export(outfile, level, namespace_, name_='userParameters', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ismrmrdHeader'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%d,\n' % self.version)
        if self.subjectInformation is not None:
            showIndent(outfile, level)
            outfile.write('subjectInformation=model_.subjectInformationType(\n')
            self.subjectInformation.exportLiteral(outfile, level, name_='subjectInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.studyInformation is not None:
            showIndent(outfile, level)
            outfile.write('studyInformation=model_.studyInformationType(\n')
            self.studyInformation.exportLiteral(outfile, level, name_='studyInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measurementInformation is not None:
            showIndent(outfile, level)
            outfile.write('measurementInformation=model_.measurementInformationType(\n')
            self.measurementInformation.exportLiteral(outfile, level, name_='measurementInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.acquisitionSystemInformation is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionSystemInformation=model_.acquisitionSystemInformationType(\n')
            self.acquisitionSystemInformation.exportLiteral(outfile, level, name_='acquisitionSystemInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.experimentalConditions is not None:
            showIndent(outfile, level)
            outfile.write('experimentalConditions=model_.experimentalConditionsType(\n')
            self.experimentalConditions.exportLiteral(outfile, level, name_='experimentalConditions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('encoding=[\n')
        level += 1
        for encoding_ in self.encoding:
            showIndent(outfile, level)
            outfile.write('model_.encoding(\n')
            encoding_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sequenceParameters is not None:
            showIndent(outfile, level)
            outfile.write('sequenceParameters=model_.sequenceParametersType(\n')
            self.sequenceParameters.exportLiteral(outfile, level, name_='sequenceParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userParameters is not None:
            showIndent(outfile, level)
            outfile.write('userParameters=model_.userParameters(\n')
            self.userParameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'subjectInformation':
            obj_ = subjectInformationType.factory()
            obj_.build(child_)
            self.subjectInformation = obj_
            obj_.original_tagname_ = 'subjectInformation'
        elif nodeName_ == 'studyInformation':
            obj_ = studyInformationType.factory()
            obj_.build(child_)
            self.studyInformation = obj_
            obj_.original_tagname_ = 'studyInformation'
        elif nodeName_ == 'measurementInformation':
            obj_ = measurementInformationType.factory()
            obj_.build(child_)
            self.measurementInformation = obj_
            obj_.original_tagname_ = 'measurementInformation'
        elif nodeName_ == 'acquisitionSystemInformation':
            obj_ = acquisitionSystemInformationType.factory()
            obj_.build(child_)
            self.acquisitionSystemInformation = obj_
            obj_.original_tagname_ = 'acquisitionSystemInformation'
        elif nodeName_ == 'experimentalConditions':
            obj_ = experimentalConditionsType.factory()
            obj_.build(child_)
            self.experimentalConditions = obj_
            obj_.original_tagname_ = 'experimentalConditions'
        elif nodeName_ == 'encoding':
            obj_ = encoding.factory()
            obj_.build(child_)
            self.encoding.append(obj_)
            obj_.original_tagname_ = 'encoding'
        elif nodeName_ == 'sequenceParameters':
            obj_ = sequenceParametersType.factory()
            obj_.build(child_)
            self.sequenceParameters = obj_
            obj_.original_tagname_ = 'sequenceParameters'
        elif nodeName_ == 'userParameters':
            obj_ = userParameters.factory()
            obj_.build(child_)
            self.userParameters = obj_
            obj_.original_tagname_ = 'userParameters'
# end class ismrmrdHeader


class subjectInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, patientName=None, patientWeight_kg=None, patientID=None, patientBirthdate=None, patientGender=None):
        self.original_tagname_ = None
        self.patientName = patientName
        self.patientWeight_kg = patientWeight_kg
        self.patientID = patientID
        if isinstance(patientBirthdate, basestring):
            initvalue_ = datetime_.datetime.strptime(patientBirthdate, '%Y-%m-%d').date()
        else:
            initvalue_ = patientBirthdate
        self.patientBirthdate = initvalue_
        self.patientGender = patientGender
        self.validate_patientGenderType(self.patientGender)
    def factory(*args_, **kwargs_):
        if subjectInformationType.subclass:
            return subjectInformationType.subclass(*args_, **kwargs_)
        else:
            return subjectInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_patientName(self): return self.patientName
    def set_patientName(self, patientName): self.patientName = patientName
    def get_patientWeight_kg(self): return self.patientWeight_kg
    def set_patientWeight_kg(self, patientWeight_kg): self.patientWeight_kg = patientWeight_kg
    def get_patientID(self): return self.patientID
    def set_patientID(self, patientID): self.patientID = patientID
    def get_patientBirthdate(self): return self.patientBirthdate
    def set_patientBirthdate(self, patientBirthdate): self.patientBirthdate = patientBirthdate
    def get_patientGender(self): return self.patientGender
    def set_patientGender(self, patientGender): self.patientGender = patientGender
    def validate_patientGenderType(self, value):
        # Validate type patientGenderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_patientGenderType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_patientGenderType_patterns_, ))
    validate_patientGenderType_patterns_ = [['^[MFO]$']]
    def hasContent_(self):
        if (
            self.patientName is not None or
            self.patientWeight_kg is not None or
            self.patientID is not None or
            self.patientBirthdate is not None or
            self.patientGender is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subjectInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subjectInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subjectInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subjectInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subjectInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.patientName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientName>%s</%spatientName>%s' % (namespace_, self.gds_format_string(quote_xml(self.patientName).encode(ExternalEncoding), input_name='patientName'), namespace_, eol_))
        if self.patientWeight_kg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientWeight_kg>%s</%spatientWeight_kg>%s' % (namespace_, self.gds_format_float(self.patientWeight_kg, input_name='patientWeight_kg'), namespace_, eol_))
        if self.patientID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientID>%s</%spatientID>%s' % (namespace_, self.gds_format_string(quote_xml(self.patientID).encode(ExternalEncoding), input_name='patientID'), namespace_, eol_))
        if self.patientBirthdate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientBirthdate>%s</%spatientBirthdate>%s' % (namespace_, self.gds_format_date(self.patientBirthdate, input_name='patientBirthdate'), namespace_, eol_))
        if self.patientGender is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientGender>%s</%spatientGender>%s' % (namespace_, self.gds_format_string(quote_xml(self.patientGender).encode(ExternalEncoding), input_name='patientGender'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='subjectInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.patientName is not None:
            showIndent(outfile, level)
            outfile.write('patientName=%s,\n' % quote_python(self.patientName).encode(ExternalEncoding))
        if self.patientWeight_kg is not None:
            showIndent(outfile, level)
            outfile.write('patientWeight_kg=%f,\n' % self.patientWeight_kg)
        if self.patientID is not None:
            showIndent(outfile, level)
            outfile.write('patientID=%s,\n' % quote_python(self.patientID).encode(ExternalEncoding))
        if self.patientBirthdate is not None:
            showIndent(outfile, level)
            outfile.write('patientBirthdate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.patientBirthdate, input_name='patientBirthdate'))
        if self.patientGender is not None:
            showIndent(outfile, level)
            outfile.write('patientGender=%s,\n' % quote_python(self.patientGender).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'patientName':
            patientName_ = child_.text
            patientName_ = self.gds_validate_string(patientName_, node, 'patientName')
            self.patientName = patientName_
        elif nodeName_ == 'patientWeight_kg':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'patientWeight_kg')
            self.patientWeight_kg = fval_
        elif nodeName_ == 'patientID':
            patientID_ = child_.text
            patientID_ = self.gds_validate_string(patientID_, node, 'patientID')
            self.patientID = patientID_
        elif nodeName_ == 'patientBirthdate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.patientBirthdate = dval_
        elif nodeName_ == 'patientGender':
            patientGender_ = child_.text
            patientGender_ = self.gds_validate_string(patientGender_, node, 'patientGender')
            self.patientGender = patientGender_
            # validate type patientGenderType
            self.validate_patientGenderType(self.patientGender)
# end class subjectInformationType


class studyInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, studyDate=None, studyTime=None, studyID=None, accessionNumber=None, referringPhysicianName=None, studyDescription=None, studyInstanceUID=None):
        self.original_tagname_ = None
        if isinstance(studyDate, basestring):
            initvalue_ = datetime_.datetime.strptime(studyDate, '%Y-%m-%d').date()
        else:
            initvalue_ = studyDate
        self.studyDate = initvalue_
        if isinstance(studyTime, basestring):
            initvalue_ = datetime_.datetime.strptime(studyTime, '%H:%M:%S').time()
        else:
            initvalue_ = studyTime
        self.studyTime = initvalue_
        self.studyID = studyID
        self.accessionNumber = accessionNumber
        self.referringPhysicianName = referringPhysicianName
        self.studyDescription = studyDescription
        self.studyInstanceUID = studyInstanceUID
    def factory(*args_, **kwargs_):
        if studyInformationType.subclass:
            return studyInformationType.subclass(*args_, **kwargs_)
        else:
            return studyInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_studyDate(self): return self.studyDate
    def set_studyDate(self, studyDate): self.studyDate = studyDate
    def get_studyTime(self): return self.studyTime
    def set_studyTime(self, studyTime): self.studyTime = studyTime
    def get_studyID(self): return self.studyID
    def set_studyID(self, studyID): self.studyID = studyID
    def get_accessionNumber(self): return self.accessionNumber
    def set_accessionNumber(self, accessionNumber): self.accessionNumber = accessionNumber
    def get_referringPhysicianName(self): return self.referringPhysicianName
    def set_referringPhysicianName(self, referringPhysicianName): self.referringPhysicianName = referringPhysicianName
    def get_studyDescription(self): return self.studyDescription
    def set_studyDescription(self, studyDescription): self.studyDescription = studyDescription
    def get_studyInstanceUID(self): return self.studyInstanceUID
    def set_studyInstanceUID(self, studyInstanceUID): self.studyInstanceUID = studyInstanceUID
    def hasContent_(self):
        if (
            self.studyDate is not None or
            self.studyTime is not None or
            self.studyID is not None or
            self.accessionNumber is not None or
            self.referringPhysicianName is not None or
            self.studyDescription is not None or
            self.studyInstanceUID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='studyInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='studyInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='studyInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='studyInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='studyInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.studyDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstudyDate>%s</%sstudyDate>%s' % (namespace_, self.gds_format_date(self.studyDate, input_name='studyDate'), namespace_, eol_))
        if self.studyTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstudyTime>%s</%sstudyTime>%s' % (namespace_, self.gds_format_time(self.studyTime, input_name='studyTime'), namespace_, eol_))
        if self.studyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstudyID>%s</%sstudyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.studyID).encode(ExternalEncoding), input_name='studyID'), namespace_, eol_))
        if self.accessionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccessionNumber>%s</%saccessionNumber>%s' % (namespace_, self.gds_format_integer(self.accessionNumber, input_name='accessionNumber'), namespace_, eol_))
        if self.referringPhysicianName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferringPhysicianName>%s</%sreferringPhysicianName>%s' % (namespace_, self.gds_format_string(quote_xml(self.referringPhysicianName).encode(ExternalEncoding), input_name='referringPhysicianName'), namespace_, eol_))
        if self.studyDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstudyDescription>%s</%sstudyDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.studyDescription).encode(ExternalEncoding), input_name='studyDescription'), namespace_, eol_))
        if self.studyInstanceUID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstudyInstanceUID>%s</%sstudyInstanceUID>%s' % (namespace_, self.gds_format_string(quote_xml(self.studyInstanceUID).encode(ExternalEncoding), input_name='studyInstanceUID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='studyInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.studyDate is not None:
            showIndent(outfile, level)
            outfile.write('studyDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.studyDate, input_name='studyDate'))
        if self.studyTime is not None:
            showIndent(outfile, level)
            outfile.write('studyTime=model_.GeneratedsSuper.gds_parse_time("%s"),\n' % self.gds_format_time(self.studyTime, input_name='studyTime'))
        if self.studyID is not None:
            showIndent(outfile, level)
            outfile.write('studyID=%s,\n' % quote_python(self.studyID).encode(ExternalEncoding))
        if self.accessionNumber is not None:
            showIndent(outfile, level)
            outfile.write('accessionNumber=%d,\n' % self.accessionNumber)
        if self.referringPhysicianName is not None:
            showIndent(outfile, level)
            outfile.write('referringPhysicianName=%s,\n' % quote_python(self.referringPhysicianName).encode(ExternalEncoding))
        if self.studyDescription is not None:
            showIndent(outfile, level)
            outfile.write('studyDescription=%s,\n' % quote_python(self.studyDescription).encode(ExternalEncoding))
        if self.studyInstanceUID is not None:
            showIndent(outfile, level)
            outfile.write('studyInstanceUID=%s,\n' % quote_python(self.studyInstanceUID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'studyDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.studyDate = dval_
        elif nodeName_ == 'studyTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.studyTime = dval_
        elif nodeName_ == 'studyID':
            studyID_ = child_.text
            studyID_ = self.gds_validate_string(studyID_, node, 'studyID')
            self.studyID = studyID_
        elif nodeName_ == 'accessionNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'accessionNumber')
            self.accessionNumber = ival_
        elif nodeName_ == 'referringPhysicianName':
            referringPhysicianName_ = child_.text
            referringPhysicianName_ = self.gds_validate_string(referringPhysicianName_, node, 'referringPhysicianName')
            self.referringPhysicianName = referringPhysicianName_
        elif nodeName_ == 'studyDescription':
            studyDescription_ = child_.text
            studyDescription_ = self.gds_validate_string(studyDescription_, node, 'studyDescription')
            self.studyDescription = studyDescription_
        elif nodeName_ == 'studyInstanceUID':
            studyInstanceUID_ = child_.text
            studyInstanceUID_ = self.gds_validate_string(studyInstanceUID_, node, 'studyInstanceUID')
            self.studyInstanceUID = studyInstanceUID_
# end class studyInformationType


class measurementInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, measurementID=None, seriesDate=None, seriesTime=None, patientPosition=None, initialSeriesNumber=None, protocolName=None, seriesDescription=None, measurementDependency=None, seriesInstanceUIDRoot=None, frameOfReferenceUID=None, referencedImageSequence=None):
        self.original_tagname_ = None
        self.measurementID = measurementID
        if isinstance(seriesDate, basestring):
            initvalue_ = datetime_.datetime.strptime(seriesDate, '%Y-%m-%d').date()
        else:
            initvalue_ = seriesDate
        self.seriesDate = initvalue_
        if isinstance(seriesTime, basestring):
            initvalue_ = datetime_.datetime.strptime(seriesTime, '%H:%M:%S').time()
        else:
            initvalue_ = seriesTime
        self.seriesTime = initvalue_
        self.patientPosition = patientPosition
        self.validate_patientPositionType(self.patientPosition)
        self.initialSeriesNumber = initialSeriesNumber
        self.protocolName = protocolName
        self.seriesDescription = seriesDescription
        if measurementDependency is None:
            self.measurementDependency = []
        else:
            self.measurementDependency = measurementDependency
        self.seriesInstanceUIDRoot = seriesInstanceUIDRoot
        self.frameOfReferenceUID = frameOfReferenceUID
        self.referencedImageSequence = referencedImageSequence
    def factory(*args_, **kwargs_):
        if measurementInformationType.subclass:
            return measurementInformationType.subclass(*args_, **kwargs_)
        else:
            return measurementInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measurementID(self): return self.measurementID
    def set_measurementID(self, measurementID): self.measurementID = measurementID
    def get_seriesDate(self): return self.seriesDate
    def set_seriesDate(self, seriesDate): self.seriesDate = seriesDate
    def get_seriesTime(self): return self.seriesTime
    def set_seriesTime(self, seriesTime): self.seriesTime = seriesTime
    def get_patientPosition(self): return self.patientPosition
    def set_patientPosition(self, patientPosition): self.patientPosition = patientPosition
    def get_initialSeriesNumber(self): return self.initialSeriesNumber
    def set_initialSeriesNumber(self, initialSeriesNumber): self.initialSeriesNumber = initialSeriesNumber
    def get_protocolName(self): return self.protocolName
    def set_protocolName(self, protocolName): self.protocolName = protocolName
    def get_seriesDescription(self): return self.seriesDescription
    def set_seriesDescription(self, seriesDescription): self.seriesDescription = seriesDescription
    def get_measurementDependency(self): return self.measurementDependency
    def set_measurementDependency(self, measurementDependency): self.measurementDependency = measurementDependency
    def add_measurementDependency(self, value): self.measurementDependency.append(value)
    def insert_measurementDependency_at(self, index, value): self.measurementDependency.insert(index, value)
    def replace_measurementDependency_at(self, index, value): self.measurementDependency[index] = value
    def get_seriesInstanceUIDRoot(self): return self.seriesInstanceUIDRoot
    def set_seriesInstanceUIDRoot(self, seriesInstanceUIDRoot): self.seriesInstanceUIDRoot = seriesInstanceUIDRoot
    def get_frameOfReferenceUID(self): return self.frameOfReferenceUID
    def set_frameOfReferenceUID(self, frameOfReferenceUID): self.frameOfReferenceUID = frameOfReferenceUID
    def get_referencedImageSequence(self): return self.referencedImageSequence
    def set_referencedImageSequence(self, referencedImageSequence): self.referencedImageSequence = referencedImageSequence
    def validate_patientPositionType(self, value):
        # Validate type patientPositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HFP', 'HFS', 'HFDR', 'HFDL', 'FFP', 'FFS', 'FFDR', 'FFDL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on patientPositionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.measurementID is not None or
            self.seriesDate is not None or
            self.seriesTime is not None or
            self.patientPosition is not None or
            self.initialSeriesNumber is not None or
            self.protocolName is not None or
            self.seriesDescription is not None or
            self.measurementDependency or
            self.seriesInstanceUIDRoot is not None or
            self.frameOfReferenceUID is not None or
            self.referencedImageSequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='measurementInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measurementInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='measurementInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='measurementInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='measurementInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.measurementID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasurementID>%s</%smeasurementID>%s' % (namespace_, self.gds_format_string(quote_xml(self.measurementID).encode(ExternalEncoding), input_name='measurementID'), namespace_, eol_))
        if self.seriesDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseriesDate>%s</%sseriesDate>%s' % (namespace_, self.gds_format_date(self.seriesDate, input_name='seriesDate'), namespace_, eol_))
        if self.seriesTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseriesTime>%s</%sseriesTime>%s' % (namespace_, self.gds_format_time(self.seriesTime, input_name='seriesTime'), namespace_, eol_))
        if self.patientPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spatientPosition>%s</%spatientPosition>%s' % (namespace_, self.gds_format_string(quote_xml(self.patientPosition).encode(ExternalEncoding), input_name='patientPosition'), namespace_, eol_))
        if self.initialSeriesNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialSeriesNumber>%s</%sinitialSeriesNumber>%s' % (namespace_, self.gds_format_integer(self.initialSeriesNumber, input_name='initialSeriesNumber'), namespace_, eol_))
        if self.protocolName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocolName>%s</%sprotocolName>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocolName).encode(ExternalEncoding), input_name='protocolName'), namespace_, eol_))
        if self.seriesDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseriesDescription>%s</%sseriesDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.seriesDescription).encode(ExternalEncoding), input_name='seriesDescription'), namespace_, eol_))
        for measurementDependency_ in self.measurementDependency:
            measurementDependency_.export(outfile, level, namespace_, name_='measurementDependency', pretty_print=pretty_print)
        if self.seriesInstanceUIDRoot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseriesInstanceUIDRoot>%s</%sseriesInstanceUIDRoot>%s' % (namespace_, self.gds_format_string(quote_xml(self.seriesInstanceUIDRoot).encode(ExternalEncoding), input_name='seriesInstanceUIDRoot'), namespace_, eol_))
        if self.frameOfReferenceUID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sframeOfReferenceUID>%s</%sframeOfReferenceUID>%s' % (namespace_, self.gds_format_string(quote_xml(self.frameOfReferenceUID).encode(ExternalEncoding), input_name='frameOfReferenceUID'), namespace_, eol_))
        if self.referencedImageSequence is not None:
            self.referencedImageSequence.export(outfile, level, namespace_, name_='referencedImageSequence', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='measurementInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.measurementID is not None:
            showIndent(outfile, level)
            outfile.write('measurementID=%s,\n' % quote_python(self.measurementID).encode(ExternalEncoding))
        if self.seriesDate is not None:
            showIndent(outfile, level)
            outfile.write('seriesDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.seriesDate, input_name='seriesDate'))
        if self.seriesTime is not None:
            showIndent(outfile, level)
            outfile.write('seriesTime=model_.GeneratedsSuper.gds_parse_time("%s"),\n' % self.gds_format_time(self.seriesTime, input_name='seriesTime'))
        if self.patientPosition is not None:
            showIndent(outfile, level)
            outfile.write('patientPosition=%s,\n' % quote_python(self.patientPosition).encode(ExternalEncoding))
        if self.initialSeriesNumber is not None:
            showIndent(outfile, level)
            outfile.write('initialSeriesNumber=%d,\n' % self.initialSeriesNumber)
        if self.protocolName is not None:
            showIndent(outfile, level)
            outfile.write('protocolName=%s,\n' % quote_python(self.protocolName).encode(ExternalEncoding))
        if self.seriesDescription is not None:
            showIndent(outfile, level)
            outfile.write('seriesDescription=%s,\n' % quote_python(self.seriesDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('measurementDependency=[\n')
        level += 1
        for measurementDependency_ in self.measurementDependency:
            showIndent(outfile, level)
            outfile.write('model_.measurementDependencyType(\n')
            measurementDependency_.exportLiteral(outfile, level, name_='measurementDependencyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seriesInstanceUIDRoot is not None:
            showIndent(outfile, level)
            outfile.write('seriesInstanceUIDRoot=%s,\n' % quote_python(self.seriesInstanceUIDRoot).encode(ExternalEncoding))
        if self.frameOfReferenceUID is not None:
            showIndent(outfile, level)
            outfile.write('frameOfReferenceUID=%s,\n' % quote_python(self.frameOfReferenceUID).encode(ExternalEncoding))
        if self.referencedImageSequence is not None:
            showIndent(outfile, level)
            outfile.write('referencedImageSequence=model_.referencedImageSequence(\n')
            self.referencedImageSequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measurementID':
            measurementID_ = child_.text
            measurementID_ = self.gds_validate_string(measurementID_, node, 'measurementID')
            self.measurementID = measurementID_
        elif nodeName_ == 'seriesDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.seriesDate = dval_
        elif nodeName_ == 'seriesTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.seriesTime = dval_
        elif nodeName_ == 'patientPosition':
            patientPosition_ = child_.text
            patientPosition_ = self.gds_validate_string(patientPosition_, node, 'patientPosition')
            self.patientPosition = patientPosition_
            # validate type patientPositionType
            self.validate_patientPositionType(self.patientPosition)
        elif nodeName_ == 'initialSeriesNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'initialSeriesNumber')
            self.initialSeriesNumber = ival_
        elif nodeName_ == 'protocolName':
            protocolName_ = child_.text
            protocolName_ = self.gds_validate_string(protocolName_, node, 'protocolName')
            self.protocolName = protocolName_
        elif nodeName_ == 'seriesDescription':
            seriesDescription_ = child_.text
            seriesDescription_ = self.gds_validate_string(seriesDescription_, node, 'seriesDescription')
            self.seriesDescription = seriesDescription_
        elif nodeName_ == 'measurementDependency':
            obj_ = measurementDependencyType.factory()
            obj_.build(child_)
            self.measurementDependency.append(obj_)
            obj_.original_tagname_ = 'measurementDependency'
        elif nodeName_ == 'seriesInstanceUIDRoot':
            seriesInstanceUIDRoot_ = child_.text
            seriesInstanceUIDRoot_ = self.gds_validate_string(seriesInstanceUIDRoot_, node, 'seriesInstanceUIDRoot')
            self.seriesInstanceUIDRoot = seriesInstanceUIDRoot_
        elif nodeName_ == 'frameOfReferenceUID':
            frameOfReferenceUID_ = child_.text
            frameOfReferenceUID_ = self.gds_validate_string(frameOfReferenceUID_, node, 'frameOfReferenceUID')
            self.frameOfReferenceUID = frameOfReferenceUID_
        elif nodeName_ == 'referencedImageSequence':
            obj_ = referencedImageSequence.factory()
            obj_.build(child_)
            self.referencedImageSequence = obj_
            obj_.original_tagname_ = 'referencedImageSequence'
# end class measurementInformationType


class measurementDependencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dependencyType=None, measurementID=None):
        self.original_tagname_ = None
        self.dependencyType = dependencyType
        self.measurementID = measurementID
    def factory(*args_, **kwargs_):
        if measurementDependencyType.subclass:
            return measurementDependencyType.subclass(*args_, **kwargs_)
        else:
            return measurementDependencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dependencyType(self): return self.dependencyType
    def set_dependencyType(self, dependencyType): self.dependencyType = dependencyType
    def get_measurementID(self): return self.measurementID
    def set_measurementID(self, measurementID): self.measurementID = measurementID
    def hasContent_(self):
        if (
            self.dependencyType is not None or
            self.measurementID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='measurementDependencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measurementDependencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='measurementDependencyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='measurementDependencyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='measurementDependencyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dependencyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdependencyType>%s</%sdependencyType>%s' % (namespace_, self.gds_format_string(quote_xml(self.dependencyType).encode(ExternalEncoding), input_name='dependencyType'), namespace_, eol_))
        if self.measurementID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasurementID>%s</%smeasurementID>%s' % (namespace_, self.gds_format_string(quote_xml(self.measurementID).encode(ExternalEncoding), input_name='measurementID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='measurementDependencyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dependencyType is not None:
            showIndent(outfile, level)
            outfile.write('dependencyType=%s,\n' % quote_python(self.dependencyType).encode(ExternalEncoding))
        if self.measurementID is not None:
            showIndent(outfile, level)
            outfile.write('measurementID=%s,\n' % quote_python(self.measurementID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dependencyType':
            dependencyType_ = child_.text
            dependencyType_ = self.gds_validate_string(dependencyType_, node, 'dependencyType')
            self.dependencyType = dependencyType_
        elif nodeName_ == 'measurementID':
            measurementID_ = child_.text
            measurementID_ = self.gds_validate_string(measurementID_, node, 'measurementID')
            self.measurementID = measurementID_
# end class measurementDependencyType


class coilLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coilNumber=None, coilName=None):
        self.original_tagname_ = None
        self.coilNumber = coilNumber
        self.coilName = coilName
    def factory(*args_, **kwargs_):
        if coilLabelType.subclass:
            return coilLabelType.subclass(*args_, **kwargs_)
        else:
            return coilLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coilNumber(self): return self.coilNumber
    def set_coilNumber(self, coilNumber): self.coilNumber = coilNumber
    def get_coilName(self): return self.coilName
    def set_coilName(self, coilName): self.coilName = coilName
    def hasContent_(self):
        if (
            self.coilNumber is not None or
            self.coilName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='coilLabelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coilLabelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='coilLabelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coilLabelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='coilLabelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coilNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoilNumber>%s</%scoilNumber>%s' % (namespace_, self.gds_format_integer(self.coilNumber, input_name='coilNumber'), namespace_, eol_))
        if self.coilName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoilName>%s</%scoilName>%s' % (namespace_, self.gds_format_string(quote_xml(self.coilName).encode(ExternalEncoding), input_name='coilName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='coilLabelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.coilNumber is not None:
            showIndent(outfile, level)
            outfile.write('coilNumber=%d,\n' % self.coilNumber)
        if self.coilName is not None:
            showIndent(outfile, level)
            outfile.write('coilName=%s,\n' % quote_python(self.coilName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coilNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'coilNumber')
            self.coilNumber = ival_
        elif nodeName_ == 'coilName':
            coilName_ = child_.text
            coilName_ = self.gds_validate_string(coilName_, node, 'coilName')
            self.coilName = coilName_
# end class coilLabelType


class acquisitionSystemInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, systemVendor=None, systemModel=None, systemFieldStrength_T=None, relativeReceiverNoiseBandwidth=None, receiverChannels=None, coilLabel=None, institutionName=None, stationName=None):
        self.original_tagname_ = None
        self.systemVendor = systemVendor
        self.systemModel = systemModel
        self.systemFieldStrength_T = systemFieldStrength_T
        self.relativeReceiverNoiseBandwidth = relativeReceiverNoiseBandwidth
        self.receiverChannels = receiverChannels
        if coilLabel is None:
            self.coilLabel = []
        else:
            self.coilLabel = coilLabel
        self.institutionName = institutionName
        self.stationName = stationName
    def factory(*args_, **kwargs_):
        if acquisitionSystemInformationType.subclass:
            return acquisitionSystemInformationType.subclass(*args_, **kwargs_)
        else:
            return acquisitionSystemInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_systemVendor(self): return self.systemVendor
    def set_systemVendor(self, systemVendor): self.systemVendor = systemVendor
    def get_systemModel(self): return self.systemModel
    def set_systemModel(self, systemModel): self.systemModel = systemModel
    def get_systemFieldStrength_T(self): return self.systemFieldStrength_T
    def set_systemFieldStrength_T(self, systemFieldStrength_T): self.systemFieldStrength_T = systemFieldStrength_T
    def get_relativeReceiverNoiseBandwidth(self): return self.relativeReceiverNoiseBandwidth
    def set_relativeReceiverNoiseBandwidth(self, relativeReceiverNoiseBandwidth): self.relativeReceiverNoiseBandwidth = relativeReceiverNoiseBandwidth
    def get_receiverChannels(self): return self.receiverChannels
    def set_receiverChannels(self, receiverChannels): self.receiverChannels = receiverChannels
    def get_coilLabel(self): return self.coilLabel
    def set_coilLabel(self, coilLabel): self.coilLabel = coilLabel
    def add_coilLabel(self, value): self.coilLabel.append(value)
    def insert_coilLabel_at(self, index, value): self.coilLabel.insert(index, value)
    def replace_coilLabel_at(self, index, value): self.coilLabel[index] = value
    def get_institutionName(self): return self.institutionName
    def set_institutionName(self, institutionName): self.institutionName = institutionName
    def get_stationName(self): return self.stationName
    def set_stationName(self, stationName): self.stationName = stationName
    def hasContent_(self):
        if (
            self.systemVendor is not None or
            self.systemModel is not None or
            self.systemFieldStrength_T is not None or
            self.relativeReceiverNoiseBandwidth is not None or
            self.receiverChannels is not None or
            self.coilLabel or
            self.institutionName is not None or
            self.stationName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='acquisitionSystemInformationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='acquisitionSystemInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='acquisitionSystemInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='acquisitionSystemInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='acquisitionSystemInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.systemVendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemVendor>%s</%ssystemVendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.systemVendor).encode(ExternalEncoding), input_name='systemVendor'), namespace_, eol_))
        if self.systemModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemModel>%s</%ssystemModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.systemModel).encode(ExternalEncoding), input_name='systemModel'), namespace_, eol_))
        if self.systemFieldStrength_T is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemFieldStrength_T>%s</%ssystemFieldStrength_T>%s' % (namespace_, self.gds_format_float(self.systemFieldStrength_T, input_name='systemFieldStrength_T'), namespace_, eol_))
        if self.relativeReceiverNoiseBandwidth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srelativeReceiverNoiseBandwidth>%s</%srelativeReceiverNoiseBandwidth>%s' % (namespace_, self.gds_format_float(self.relativeReceiverNoiseBandwidth, input_name='relativeReceiverNoiseBandwidth'), namespace_, eol_))
        if self.receiverChannels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreceiverChannels>%s</%sreceiverChannels>%s' % (namespace_, self.gds_format_integer(self.receiverChannels, input_name='receiverChannels'), namespace_, eol_))
        for coilLabel_ in self.coilLabel:
            coilLabel_.export(outfile, level, namespace_, name_='coilLabel', pretty_print=pretty_print)
        if self.institutionName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstitutionName>%s</%sinstitutionName>%s' % (namespace_, self.gds_format_string(quote_xml(self.institutionName).encode(ExternalEncoding), input_name='institutionName'), namespace_, eol_))
        if self.stationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstationName>%s</%sstationName>%s' % (namespace_, self.gds_format_string(quote_xml(self.stationName).encode(ExternalEncoding), input_name='stationName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='acquisitionSystemInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.systemVendor is not None:
            showIndent(outfile, level)
            outfile.write('systemVendor=%s,\n' % quote_python(self.systemVendor).encode(ExternalEncoding))
        if self.systemModel is not None:
            showIndent(outfile, level)
            outfile.write('systemModel=%s,\n' % quote_python(self.systemModel).encode(ExternalEncoding))
        if self.systemFieldStrength_T is not None:
            showIndent(outfile, level)
            outfile.write('systemFieldStrength_T=%f,\n' % self.systemFieldStrength_T)
        if self.relativeReceiverNoiseBandwidth is not None:
            showIndent(outfile, level)
            outfile.write('relativeReceiverNoiseBandwidth=%f,\n' % self.relativeReceiverNoiseBandwidth)
        if self.receiverChannels is not None:
            showIndent(outfile, level)
            outfile.write('receiverChannels=%d,\n' % self.receiverChannels)
        showIndent(outfile, level)
        outfile.write('coilLabel=[\n')
        level += 1
        for coilLabel_ in self.coilLabel:
            showIndent(outfile, level)
            outfile.write('model_.coilLabelType(\n')
            coilLabel_.exportLiteral(outfile, level, name_='coilLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.institutionName is not None:
            showIndent(outfile, level)
            outfile.write('institutionName=%s,\n' % quote_python(self.institutionName).encode(ExternalEncoding))
        if self.stationName is not None:
            showIndent(outfile, level)
            outfile.write('stationName=%s,\n' % quote_python(self.stationName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'systemVendor':
            systemVendor_ = child_.text
            systemVendor_ = self.gds_validate_string(systemVendor_, node, 'systemVendor')
            self.systemVendor = systemVendor_
        elif nodeName_ == 'systemModel':
            systemModel_ = child_.text
            systemModel_ = self.gds_validate_string(systemModel_, node, 'systemModel')
            self.systemModel = systemModel_
        elif nodeName_ == 'systemFieldStrength_T':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'systemFieldStrength_T')
            self.systemFieldStrength_T = fval_
        elif nodeName_ == 'relativeReceiverNoiseBandwidth':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'relativeReceiverNoiseBandwidth')
            self.relativeReceiverNoiseBandwidth = fval_
        elif nodeName_ == 'receiverChannels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'receiverChannels')
            self.receiverChannels = ival_
        elif nodeName_ == 'coilLabel':
            obj_ = coilLabelType.factory()
            obj_.build(child_)
            self.coilLabel.append(obj_)
            obj_.original_tagname_ = 'coilLabel'
        elif nodeName_ == 'institutionName':
            institutionName_ = child_.text
            institutionName_ = self.gds_validate_string(institutionName_, node, 'institutionName')
            self.institutionName = institutionName_
        elif nodeName_ == 'stationName':
            stationName_ = child_.text
            stationName_ = self.gds_validate_string(stationName_, node, 'stationName')
            self.stationName = stationName_
# end class acquisitionSystemInformationType


class experimentalConditionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, H1resonanceFrequency_Hz=None):
        self.original_tagname_ = None
        self.H1resonanceFrequency_Hz = H1resonanceFrequency_Hz
    def factory(*args_, **kwargs_):
        if experimentalConditionsType.subclass:
            return experimentalConditionsType.subclass(*args_, **kwargs_)
        else:
            return experimentalConditionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_H1resonanceFrequency_Hz(self): return self.H1resonanceFrequency_Hz
    def set_H1resonanceFrequency_Hz(self, H1resonanceFrequency_Hz): self.H1resonanceFrequency_Hz = H1resonanceFrequency_Hz
    def hasContent_(self):
        if (
            self.H1resonanceFrequency_Hz is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='experimentalConditionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='experimentalConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='experimentalConditionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='experimentalConditionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='experimentalConditionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.H1resonanceFrequency_Hz is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sH1resonanceFrequency_Hz>%s</%sH1resonanceFrequency_Hz>%s' % (namespace_, self.gds_format_integer(self.H1resonanceFrequency_Hz, input_name='H1resonanceFrequency_Hz'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='experimentalConditionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.H1resonanceFrequency_Hz is not None:
            showIndent(outfile, level)
            outfile.write('H1resonanceFrequency_Hz=%d,\n' % self.H1resonanceFrequency_Hz)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'H1resonanceFrequency_Hz':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'H1resonanceFrequency_Hz')
            self.H1resonanceFrequency_Hz = ival_
# end class experimentalConditionsType


class encoding(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, encodedSpace=None, reconSpace=None, encodingLimits=None, trajectory=None, trajectoryDescription=None, parallelImaging=None, echoTrainLength=None):
        self.original_tagname_ = None
        self.encodedSpace = encodedSpace
        self.reconSpace = reconSpace
        self.encodingLimits = encodingLimits
        self.trajectory = trajectory
        self.validate_trajectoryType(self.trajectory)
        self.trajectoryDescription = trajectoryDescription
        self.parallelImaging = parallelImaging
        self.echoTrainLength = echoTrainLength
    def factory(*args_, **kwargs_):
        if encoding.subclass:
            return encoding.subclass(*args_, **kwargs_)
        else:
            return encoding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_encodedSpace(self): return self.encodedSpace
    def set_encodedSpace(self, encodedSpace): self.encodedSpace = encodedSpace
    def get_reconSpace(self): return self.reconSpace
    def set_reconSpace(self, reconSpace): self.reconSpace = reconSpace
    def get_encodingLimits(self): return self.encodingLimits
    def set_encodingLimits(self, encodingLimits): self.encodingLimits = encodingLimits
    def get_trajectory(self): return self.trajectory
    def set_trajectory(self, trajectory): self.trajectory = trajectory
    def get_trajectoryDescription(self): return self.trajectoryDescription
    def set_trajectoryDescription(self, trajectoryDescription): self.trajectoryDescription = trajectoryDescription
    def get_parallelImaging(self): return self.parallelImaging
    def set_parallelImaging(self, parallelImaging): self.parallelImaging = parallelImaging
    def get_echoTrainLength(self): return self.echoTrainLength
    def set_echoTrainLength(self, echoTrainLength): self.echoTrainLength = echoTrainLength
    def validate_trajectoryType(self, value):
        # Validate type trajectoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cartesian', 'epi', 'radial', 'goldenangle', 'spiral', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on trajectoryType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.encodedSpace is not None or
            self.reconSpace is not None or
            self.encodingLimits is not None or
            self.trajectory is not None or
            self.trajectoryDescription is not None or
            self.parallelImaging is not None or
            self.echoTrainLength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='encoding', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='encoding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='encoding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='encoding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='encoding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.encodedSpace is not None:
            self.encodedSpace.export(outfile, level, namespace_, name_='encodedSpace', pretty_print=pretty_print)
        if self.reconSpace is not None:
            self.reconSpace.export(outfile, level, namespace_, name_='reconSpace', pretty_print=pretty_print)
        if self.encodingLimits is not None:
            self.encodingLimits.export(outfile, level, namespace_, name_='encodingLimits', pretty_print=pretty_print)
        if self.trajectory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%strajectory>%s</%strajectory>%s' % (namespace_, self.gds_format_string(quote_xml(self.trajectory).encode(ExternalEncoding), input_name='trajectory'), namespace_, eol_))
        if self.trajectoryDescription is not None:
            self.trajectoryDescription.export(outfile, level, namespace_, name_='trajectoryDescription', pretty_print=pretty_print)
        if self.parallelImaging is not None:
            self.parallelImaging.export(outfile, level, namespace_, name_='parallelImaging', pretty_print=pretty_print)
        if self.echoTrainLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sechoTrainLength>%s</%sechoTrainLength>%s' % (namespace_, self.gds_format_integer(self.echoTrainLength, input_name='echoTrainLength'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='encoding'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.encodedSpace is not None:
            showIndent(outfile, level)
            outfile.write('encodedSpace=model_.encodingSpaceType(\n')
            self.encodedSpace.exportLiteral(outfile, level, name_='encodedSpace')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reconSpace is not None:
            showIndent(outfile, level)
            outfile.write('reconSpace=model_.encodingSpaceType(\n')
            self.reconSpace.exportLiteral(outfile, level, name_='reconSpace')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.encodingLimits is not None:
            showIndent(outfile, level)
            outfile.write('encodingLimits=model_.encodingLimitsType(\n')
            self.encodingLimits.exportLiteral(outfile, level, name_='encodingLimits')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trajectory is not None:
            showIndent(outfile, level)
            outfile.write('trajectory=%s,\n' % quote_python(self.trajectory).encode(ExternalEncoding))
        if self.trajectoryDescription is not None:
            showIndent(outfile, level)
            outfile.write('trajectoryDescription=model_.trajectoryDescriptionType(\n')
            self.trajectoryDescription.exportLiteral(outfile, level, name_='trajectoryDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parallelImaging is not None:
            showIndent(outfile, level)
            outfile.write('parallelImaging=model_.parallelImagingType(\n')
            self.parallelImaging.exportLiteral(outfile, level, name_='parallelImaging')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.echoTrainLength is not None:
            showIndent(outfile, level)
            outfile.write('echoTrainLength=%d,\n' % self.echoTrainLength)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'encodedSpace':
            obj_ = encodingSpaceType.factory()
            obj_.build(child_)
            self.encodedSpace = obj_
            obj_.original_tagname_ = 'encodedSpace'
        elif nodeName_ == 'reconSpace':
            obj_ = encodingSpaceType.factory()
            obj_.build(child_)
            self.reconSpace = obj_
            obj_.original_tagname_ = 'reconSpace'
        elif nodeName_ == 'encodingLimits':
            obj_ = encodingLimitsType.factory()
            obj_.build(child_)
            self.encodingLimits = obj_
            obj_.original_tagname_ = 'encodingLimits'
        elif nodeName_ == 'trajectory':
            trajectory_ = child_.text
            trajectory_ = self.gds_validate_string(trajectory_, node, 'trajectory')
            self.trajectory = trajectory_
            # validate type trajectoryType
            self.validate_trajectoryType(self.trajectory)
        elif nodeName_ == 'trajectoryDescription':
            obj_ = trajectoryDescriptionType.factory()
            obj_.build(child_)
            self.trajectoryDescription = obj_
            obj_.original_tagname_ = 'trajectoryDescription'
        elif nodeName_ == 'parallelImaging':
            obj_ = parallelImagingType.factory()
            obj_.build(child_)
            self.parallelImaging = obj_
            obj_.original_tagname_ = 'parallelImaging'
        elif nodeName_ == 'echoTrainLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'echoTrainLength')
            self.echoTrainLength = ival_
# end class encoding


class encodingSpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, matrixSize=None, fieldOfView_mm=None):
        self.original_tagname_ = None
        self.matrixSize = matrixSize
        self.fieldOfView_mm = fieldOfView_mm
    def factory(*args_, **kwargs_):
        if encodingSpaceType.subclass:
            return encodingSpaceType.subclass(*args_, **kwargs_)
        else:
            return encodingSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixSize(self): return self.matrixSize
    def set_matrixSize(self, matrixSize): self.matrixSize = matrixSize
    def get_fieldOfView_mm(self): return self.fieldOfView_mm
    def set_fieldOfView_mm(self, fieldOfView_mm): self.fieldOfView_mm = fieldOfView_mm
    def hasContent_(self):
        if (
            self.matrixSize is not None or
            self.fieldOfView_mm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='encodingSpaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='encodingSpaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='encodingSpaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='encodingSpaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='encodingSpaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matrixSize is not None:
            self.matrixSize.export(outfile, level, namespace_, name_='matrixSize', pretty_print=pretty_print)
        if self.fieldOfView_mm is not None:
            self.fieldOfView_mm.export(outfile, level, namespace_, name_='fieldOfView_mm', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='encodingSpaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.matrixSize is not None:
            showIndent(outfile, level)
            outfile.write('matrixSize=model_.matrixSize(\n')
            self.matrixSize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fieldOfView_mm is not None:
            showIndent(outfile, level)
            outfile.write('fieldOfView_mm=model_.fieldOfView_mm(\n')
            self.fieldOfView_mm.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matrixSize':
            obj_ = matrixSize.factory()
            obj_.build(child_)
            self.matrixSize = obj_
            obj_.original_tagname_ = 'matrixSize'
        elif nodeName_ == 'fieldOfView_mm':
            obj_ = fieldOfView_mm.factory()
            obj_.build(child_)
            self.fieldOfView_mm = obj_
            obj_.original_tagname_ = 'fieldOfView_mm'
# end class encodingSpaceType


class matrixSize(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, x=1, y=1, z=1):
        self.original_tagname_ = None
        self.x = x
        self.y = y
        self.z = z
    def factory(*args_, **kwargs_):
        if matrixSize.subclass:
            return matrixSize.subclass(*args_, **kwargs_)
        else:
            return matrixSize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def hasContent_(self):
        if (
            self.x != 1 or
            self.y != 1 or
            self.z != 1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrixSize', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrixSize')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrixSize', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrixSize'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='matrixSize', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x != 1:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sx>%s</%sx>%s' % (namespace_, self.gds_format_integer(self.x, input_name='x'), namespace_, eol_))
        if self.y != 1:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sy>%s</%sy>%s' % (namespace_, self.gds_format_integer(self.y, input_name='y'), namespace_, eol_))
        if self.z != 1:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sz>%s</%sz>%s' % (namespace_, self.gds_format_integer(self.z, input_name='z'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='matrixSize'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=%d,\n' % self.x)
        if self.y is not None:
            showIndent(outfile, level)
            outfile.write('y=%d,\n' % self.y)
        if self.z is not None:
            showIndent(outfile, level)
            outfile.write('z=%d,\n' % self.z)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'x':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'x')
            self.x = ival_
        elif nodeName_ == 'y':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'y')
            self.y = ival_
        elif nodeName_ == 'z':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'z')
            self.z = ival_
# end class matrixSize


class fieldOfView_mm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, z=None):
        self.original_tagname_ = None
        self.x = x
        self.y = y
        self.z = z
    def factory(*args_, **kwargs_):
        if fieldOfView_mm.subclass:
            return fieldOfView_mm.subclass(*args_, **kwargs_)
        else:
            return fieldOfView_mm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def hasContent_(self):
        if (
            self.x is not None or
            self.y is not None or
            self.z is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fieldOfView_mm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fieldOfView_mm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fieldOfView_mm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fieldOfView_mm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fieldOfView_mm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sx>%s</%sx>%s' % (namespace_, self.gds_format_float(self.x, input_name='x'), namespace_, eol_))
        if self.y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sy>%s</%sy>%s' % (namespace_, self.gds_format_float(self.y, input_name='y'), namespace_, eol_))
        if self.z is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sz>%s</%sz>%s' % (namespace_, self.gds_format_float(self.z, input_name='z'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='fieldOfView_mm'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % self.x)
        if self.y is not None:
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % self.y)
        if self.z is not None:
            showIndent(outfile, level)
            outfile.write('z=%f,\n' % self.z)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'x':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'x')
            self.x = fval_
        elif nodeName_ == 'y':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'y')
            self.y = fval_
        elif nodeName_ == 'z':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'z')
            self.z = fval_
# end class fieldOfView_mm


class limitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, minimum=0, maximum=0, center=0):
        self.original_tagname_ = None
        self.minimum = minimum
        self.maximum = maximum
        self.center = center
    def factory(*args_, **kwargs_):
        if limitType.subclass:
            return limitType.subclass(*args_, **kwargs_)
        else:
            return limitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_center(self): return self.center
    def set_center(self, center): self.center = center
    def hasContent_(self):
        if (
            self.minimum != 0 or
            self.maximum != 0 or
            self.center != 0
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='limitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='limitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='limitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='limitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum != 0:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimum>%s</%sminimum>%s' % (namespace_, self.gds_format_integer(self.minimum, input_name='minimum'), namespace_, eol_))
        if self.maximum != 0:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximum>%s</%smaximum>%s' % (namespace_, self.gds_format_integer(self.maximum, input_name='maximum'), namespace_, eol_))
        if self.center != 0:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scenter>%s</%scenter>%s' % (namespace_, self.gds_format_integer(self.center, input_name='center'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='limitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.minimum is not None:
            showIndent(outfile, level)
            outfile.write('minimum=%d,\n' % self.minimum)
        if self.maximum is not None:
            showIndent(outfile, level)
            outfile.write('maximum=%d,\n' % self.maximum)
        if self.center is not None:
            showIndent(outfile, level)
            outfile.write('center=%d,\n' % self.center)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimum':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minimum')
            self.minimum = ival_
        elif nodeName_ == 'maximum':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maximum')
            self.maximum = ival_
        elif nodeName_ == 'center':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'center')
            self.center = ival_
# end class limitType


class encodingLimitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kspace_encoding_step_0=None, kspace_encoding_step_1=None, kspace_encoding_step_2=None, average=None, slice=None, contrast=None, phase=None, repetition=None, set=None, segment=None):
        self.original_tagname_ = None
        self.kspace_encoding_step_0 = kspace_encoding_step_0
        self.kspace_encoding_step_1 = kspace_encoding_step_1
        self.kspace_encoding_step_2 = kspace_encoding_step_2
        self.average = average
        self.slice = slice
        self.contrast = contrast
        self.phase = phase
        self.repetition = repetition
        self.set = set
        self.segment = segment
    def factory(*args_, **kwargs_):
        if encodingLimitsType.subclass:
            return encodingLimitsType.subclass(*args_, **kwargs_)
        else:
            return encodingLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kspace_encoding_step_0(self): return self.kspace_encoding_step_0
    def set_kspace_encoding_step_0(self, kspace_encoding_step_0): self.kspace_encoding_step_0 = kspace_encoding_step_0
    def get_kspace_encoding_step_1(self): return self.kspace_encoding_step_1
    def set_kspace_encoding_step_1(self, kspace_encoding_step_1): self.kspace_encoding_step_1 = kspace_encoding_step_1
    def get_kspace_encoding_step_2(self): return self.kspace_encoding_step_2
    def set_kspace_encoding_step_2(self, kspace_encoding_step_2): self.kspace_encoding_step_2 = kspace_encoding_step_2
    def get_average(self): return self.average
    def set_average(self, average): self.average = average
    def get_slice(self): return self.slice
    def set_slice(self, slice): self.slice = slice
    def get_contrast(self): return self.contrast
    def set_contrast(self, contrast): self.contrast = contrast
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_repetition(self): return self.repetition
    def set_repetition(self, repetition): self.repetition = repetition
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def hasContent_(self):
        if (
            self.kspace_encoding_step_0 is not None or
            self.kspace_encoding_step_1 is not None or
            self.kspace_encoding_step_2 is not None or
            self.average is not None or
            self.slice is not None or
            self.contrast is not None or
            self.phase is not None or
            self.repetition is not None or
            self.set is not None or
            self.segment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='encodingLimitsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='encodingLimitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='encodingLimitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='encodingLimitsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='encodingLimitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kspace_encoding_step_0 is not None:
            self.kspace_encoding_step_0.export(outfile, level, namespace_, name_='kspace_encoding_step_0', pretty_print=pretty_print)
        if self.kspace_encoding_step_1 is not None:
            self.kspace_encoding_step_1.export(outfile, level, namespace_, name_='kspace_encoding_step_1', pretty_print=pretty_print)
        if self.kspace_encoding_step_2 is not None:
            self.kspace_encoding_step_2.export(outfile, level, namespace_, name_='kspace_encoding_step_2', pretty_print=pretty_print)
        if self.average is not None:
            self.average.export(outfile, level, namespace_, name_='average', pretty_print=pretty_print)
        if self.slice is not None:
            self.slice.export(outfile, level, namespace_, name_='slice', pretty_print=pretty_print)
        if self.contrast is not None:
            self.contrast.export(outfile, level, namespace_, name_='contrast', pretty_print=pretty_print)
        if self.phase is not None:
            self.phase.export(outfile, level, namespace_, name_='phase', pretty_print=pretty_print)
        if self.repetition is not None:
            self.repetition.export(outfile, level, namespace_, name_='repetition', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespace_, name_='set', pretty_print=pretty_print)
        if self.segment is not None:
            self.segment.export(outfile, level, namespace_, name_='segment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='encodingLimitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.kspace_encoding_step_0 is not None:
            showIndent(outfile, level)
            outfile.write('kspace_encoding_step_0=model_.limitType(\n')
            self.kspace_encoding_step_0.exportLiteral(outfile, level, name_='kspace_encoding_step_0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kspace_encoding_step_1 is not None:
            showIndent(outfile, level)
            outfile.write('kspace_encoding_step_1=model_.limitType(\n')
            self.kspace_encoding_step_1.exportLiteral(outfile, level, name_='kspace_encoding_step_1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kspace_encoding_step_2 is not None:
            showIndent(outfile, level)
            outfile.write('kspace_encoding_step_2=model_.limitType(\n')
            self.kspace_encoding_step_2.exportLiteral(outfile, level, name_='kspace_encoding_step_2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.average is not None:
            showIndent(outfile, level)
            outfile.write('average=model_.limitType(\n')
            self.average.exportLiteral(outfile, level, name_='average')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.slice is not None:
            showIndent(outfile, level)
            outfile.write('slice=model_.limitType(\n')
            self.slice.exportLiteral(outfile, level, name_='slice')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contrast is not None:
            showIndent(outfile, level)
            outfile.write('contrast=model_.limitType(\n')
            self.contrast.exportLiteral(outfile, level, name_='contrast')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.phase is not None:
            showIndent(outfile, level)
            outfile.write('phase=model_.limitType(\n')
            self.phase.exportLiteral(outfile, level, name_='phase')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repetition is not None:
            showIndent(outfile, level)
            outfile.write('repetition=model_.limitType(\n')
            self.repetition.exportLiteral(outfile, level, name_='repetition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.limitType(\n')
            self.set.exportLiteral(outfile, level, name_='set')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.segment is not None:
            showIndent(outfile, level)
            outfile.write('segment=model_.limitType(\n')
            self.segment.exportLiteral(outfile, level, name_='segment')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kspace_encoding_step_0':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.kspace_encoding_step_0 = obj_
            obj_.original_tagname_ = 'kspace_encoding_step_0'
        elif nodeName_ == 'kspace_encoding_step_1':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.kspace_encoding_step_1 = obj_
            obj_.original_tagname_ = 'kspace_encoding_step_1'
        elif nodeName_ == 'kspace_encoding_step_2':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.kspace_encoding_step_2 = obj_
            obj_.original_tagname_ = 'kspace_encoding_step_2'
        elif nodeName_ == 'average':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.average = obj_
            obj_.original_tagname_ = 'average'
        elif nodeName_ == 'slice':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.slice = obj_
            obj_.original_tagname_ = 'slice'
        elif nodeName_ == 'contrast':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.contrast = obj_
            obj_.original_tagname_ = 'contrast'
        elif nodeName_ == 'phase':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'repetition':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.repetition = obj_
            obj_.original_tagname_ = 'repetition'
        elif nodeName_ == 'set':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'segment':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.segment = obj_
            obj_.original_tagname_ = 'segment'
# end class encodingLimitsType


class trajectoryDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifier=None, userParameterLong=None, userParameterDouble=None, comment=None):
        self.original_tagname_ = None
        self.identifier = identifier
        if userParameterLong is None:
            self.userParameterLong = []
        else:
            self.userParameterLong = userParameterLong
        if userParameterDouble is None:
            self.userParameterDouble = []
        else:
            self.userParameterDouble = userParameterDouble
        self.comment = comment
    def factory(*args_, **kwargs_):
        if trajectoryDescriptionType.subclass:
            return trajectoryDescriptionType.subclass(*args_, **kwargs_)
        else:
            return trajectoryDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_userParameterLong(self): return self.userParameterLong
    def set_userParameterLong(self, userParameterLong): self.userParameterLong = userParameterLong
    def add_userParameterLong(self, value): self.userParameterLong.append(value)
    def insert_userParameterLong_at(self, index, value): self.userParameterLong.insert(index, value)
    def replace_userParameterLong_at(self, index, value): self.userParameterLong[index] = value
    def get_userParameterDouble(self): return self.userParameterDouble
    def set_userParameterDouble(self, userParameterDouble): self.userParameterDouble = userParameterDouble
    def add_userParameterDouble(self, value): self.userParameterDouble.append(value)
    def insert_userParameterDouble_at(self, index, value): self.userParameterDouble.insert(index, value)
    def replace_userParameterDouble_at(self, index, value): self.userParameterDouble[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def hasContent_(self):
        if (
            self.identifier is not None or
            self.userParameterLong or
            self.userParameterDouble or
            self.comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='trajectoryDescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trajectoryDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='trajectoryDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='trajectoryDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='trajectoryDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.identifier).encode(ExternalEncoding), input_name='identifier'), namespace_, eol_))
        for userParameterLong_ in self.userParameterLong:
            userParameterLong_.export(outfile, level, namespace_, name_='userParameterLong', pretty_print=pretty_print)
        for userParameterDouble_ in self.userParameterDouble:
            userParameterDouble_.export(outfile, level, namespace_, name_='userParameterDouble', pretty_print=pretty_print)
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='trajectoryDescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=%s,\n' % quote_python(self.identifier).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('userParameterLong=[\n')
        level += 1
        for userParameterLong_ in self.userParameterLong:
            showIndent(outfile, level)
            outfile.write('model_.userParameterLongType(\n')
            userParameterLong_.exportLiteral(outfile, level, name_='userParameterLongType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParameterDouble=[\n')
        level += 1
        for userParameterDouble_ in self.userParameterDouble:
            showIndent(outfile, level)
            outfile.write('model_.userParameterDoubleType(\n')
            userParameterDouble_.exportLiteral(outfile, level, name_='userParameterDoubleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
        elif nodeName_ == 'userParameterLong':
            obj_ = userParameterLongType.factory()
            obj_.build(child_)
            self.userParameterLong.append(obj_)
            obj_.original_tagname_ = 'userParameterLong'
        elif nodeName_ == 'userParameterDouble':
            obj_ = userParameterDoubleType.factory()
            obj_.build(child_)
            self.userParameterDouble.append(obj_)
            obj_.original_tagname_ = 'userParameterDouble'
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class trajectoryDescriptionType


class sequenceParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TR=None, TE=None, TI=None, flipAngle_deg=None):
        self.original_tagname_ = None
        if TR is None:
            self.TR = []
        else:
            self.TR = TR
        if TE is None:
            self.TE = []
        else:
            self.TE = TE
        if TI is None:
            self.TI = []
        else:
            self.TI = TI
        if flipAngle_deg is None:
            self.flipAngle_deg = []
        else:
            self.flipAngle_deg = flipAngle_deg
    def factory(*args_, **kwargs_):
        if sequenceParametersType.subclass:
            return sequenceParametersType.subclass(*args_, **kwargs_)
        else:
            return sequenceParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TR(self): return self.TR
    def set_TR(self, TR): self.TR = TR
    def add_TR(self, value): self.TR.append(value)
    def insert_TR_at(self, index, value): self.TR.insert(index, value)
    def replace_TR_at(self, index, value): self.TR[index] = value
    def get_TE(self): return self.TE
    def set_TE(self, TE): self.TE = TE
    def add_TE(self, value): self.TE.append(value)
    def insert_TE_at(self, index, value): self.TE.insert(index, value)
    def replace_TE_at(self, index, value): self.TE[index] = value
    def get_TI(self): return self.TI
    def set_TI(self, TI): self.TI = TI
    def add_TI(self, value): self.TI.append(value)
    def insert_TI_at(self, index, value): self.TI.insert(index, value)
    def replace_TI_at(self, index, value): self.TI[index] = value
    def get_flipAngle_deg(self): return self.flipAngle_deg
    def set_flipAngle_deg(self, flipAngle_deg): self.flipAngle_deg = flipAngle_deg
    def add_flipAngle_deg(self, value): self.flipAngle_deg.append(value)
    def insert_flipAngle_deg_at(self, index, value): self.flipAngle_deg.insert(index, value)
    def replace_flipAngle_deg_at(self, index, value): self.flipAngle_deg[index] = value
    def hasContent_(self):
        if (
            self.TR or
            self.TE or
            self.TI or
            self.flipAngle_deg
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequenceParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TR_ in self.TR:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTR>%s</%sTR>%s' % (namespace_, self.gds_format_float(TR_, input_name='TR'), namespace_, eol_))
        for TE_ in self.TE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTE>%s</%sTE>%s' % (namespace_, self.gds_format_float(TE_, input_name='TE'), namespace_, eol_))
        for TI_ in self.TI:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTI>%s</%sTI>%s' % (namespace_, self.gds_format_float(TI_, input_name='TI'), namespace_, eol_))
        for flipAngle_deg_ in self.flipAngle_deg:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflipAngle_deg>%s</%sflipAngle_deg>%s' % (namespace_, self.gds_format_float(flipAngle_deg_, input_name='flipAngle_deg'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='sequenceParametersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TR=[\n')
        level += 1
        for TR_ in self.TR:
            showIndent(outfile, level)
            outfile.write('%f,\n' % TR_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TE=[\n')
        level += 1
        for TE_ in self.TE:
            showIndent(outfile, level)
            outfile.write('%f,\n' % TE_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TI=[\n')
        level += 1
        for TI_ in self.TI:
            showIndent(outfile, level)
            outfile.write('%f,\n' % TI_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('flipAngle_deg=[\n')
        level += 1
        for flipAngle_deg_ in self.flipAngle_deg:
            showIndent(outfile, level)
            outfile.write('%f,\n' % flipAngle_deg_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TR')
            self.TR.append(fval_)
        elif nodeName_ == 'TE':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TE')
            self.TE.append(fval_)
        elif nodeName_ == 'TI':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TI')
            self.TI.append(fval_)
        elif nodeName_ == 'flipAngle_deg':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'flipAngle_deg')
            self.flipAngle_deg.append(fval_)
# end class sequenceParametersType


class userParameterLongType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if userParameterLongType.subclass:
            return userParameterLongType.subclass(*args_, **kwargs_)
        else:
            return userParameterLongType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='userParameterLongType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userParameterLongType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='userParameterLongType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='userParameterLongType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='userParameterLongType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='userParameterLongType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
# end class userParameterLongType


class userParameterDoubleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if userParameterDoubleType.subclass:
            return userParameterDoubleType.subclass(*args_, **kwargs_)
        else:
            return userParameterDoubleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='userParameterDoubleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userParameterDoubleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='userParameterDoubleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='userParameterDoubleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='userParameterDoubleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_double(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='userParameterDoubleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
# end class userParameterDoubleType


class userParameterStringType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if userParameterStringType.subclass:
            return userParameterStringType.subclass(*args_, **kwargs_)
        else:
            return userParameterStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='userParameterStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userParameterStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='userParameterStringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='userParameterStringType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='userParameterStringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='userParameterStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class userParameterStringType


class userParameterBase64Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if userParameterBase64Type.subclass:
            return userParameterBase64Type.subclass(*args_, **kwargs_)
        else:
            return userParameterBase64Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='userParameterBase64Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userParameterBase64Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='userParameterBase64Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='userParameterBase64Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='userParameterBase64Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_base64(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='userParameterBase64Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.xs_base64Binary(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'value')
            else:
                bval_ = None
            self.value = bval_
# end class userParameterBase64Type


class referencedImageSequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, referencedSOPInstanceUID=None):
        self.original_tagname_ = None
        if referencedSOPInstanceUID is None:
            self.referencedSOPInstanceUID = []
        else:
            self.referencedSOPInstanceUID = referencedSOPInstanceUID
    def factory(*args_, **kwargs_):
        if referencedImageSequence.subclass:
            return referencedImageSequence.subclass(*args_, **kwargs_)
        else:
            return referencedImageSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referencedSOPInstanceUID(self): return self.referencedSOPInstanceUID
    def set_referencedSOPInstanceUID(self, referencedSOPInstanceUID): self.referencedSOPInstanceUID = referencedSOPInstanceUID
    def add_referencedSOPInstanceUID(self, value): self.referencedSOPInstanceUID.append(value)
    def insert_referencedSOPInstanceUID_at(self, index, value): self.referencedSOPInstanceUID.insert(index, value)
    def replace_referencedSOPInstanceUID_at(self, index, value): self.referencedSOPInstanceUID[index] = value
    def hasContent_(self):
        if (
            self.referencedSOPInstanceUID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='referencedImageSequence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='referencedImageSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='referencedImageSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='referencedImageSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='referencedImageSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referencedSOPInstanceUID_ in self.referencedSOPInstanceUID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferencedSOPInstanceUID>%s</%sreferencedSOPInstanceUID>%s' % (namespace_, self.gds_format_string(quote_xml(referencedSOPInstanceUID_).encode(ExternalEncoding), input_name='referencedSOPInstanceUID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='referencedImageSequence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('referencedSOPInstanceUID=[\n')
        level += 1
        for referencedSOPInstanceUID_ in self.referencedSOPInstanceUID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(referencedSOPInstanceUID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referencedSOPInstanceUID':
            referencedSOPInstanceUID_ = child_.text
            referencedSOPInstanceUID_ = self.gds_validate_string(referencedSOPInstanceUID_, node, 'referencedSOPInstanceUID')
            self.referencedSOPInstanceUID.append(referencedSOPInstanceUID_)
# end class referencedImageSequence


class userParameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, userParameterLong=None, userParameterDouble=None, userParameterString=None, userParameterBase64=None):
        self.original_tagname_ = None
        if userParameterLong is None:
            self.userParameterLong = []
        else:
            self.userParameterLong = userParameterLong
        if userParameterDouble is None:
            self.userParameterDouble = []
        else:
            self.userParameterDouble = userParameterDouble
        if userParameterString is None:
            self.userParameterString = []
        else:
            self.userParameterString = userParameterString
        if userParameterBase64 is None:
            self.userParameterBase64 = []
        else:
            self.userParameterBase64 = userParameterBase64
    def factory(*args_, **kwargs_):
        if userParameters.subclass:
            return userParameters.subclass(*args_, **kwargs_)
        else:
            return userParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userParameterLong(self): return self.userParameterLong
    def set_userParameterLong(self, userParameterLong): self.userParameterLong = userParameterLong
    def add_userParameterLong(self, value): self.userParameterLong.append(value)
    def insert_userParameterLong_at(self, index, value): self.userParameterLong.insert(index, value)
    def replace_userParameterLong_at(self, index, value): self.userParameterLong[index] = value
    def get_userParameterDouble(self): return self.userParameterDouble
    def set_userParameterDouble(self, userParameterDouble): self.userParameterDouble = userParameterDouble
    def add_userParameterDouble(self, value): self.userParameterDouble.append(value)
    def insert_userParameterDouble_at(self, index, value): self.userParameterDouble.insert(index, value)
    def replace_userParameterDouble_at(self, index, value): self.userParameterDouble[index] = value
    def get_userParameterString(self): return self.userParameterString
    def set_userParameterString(self, userParameterString): self.userParameterString = userParameterString
    def add_userParameterString(self, value): self.userParameterString.append(value)
    def insert_userParameterString_at(self, index, value): self.userParameterString.insert(index, value)
    def replace_userParameterString_at(self, index, value): self.userParameterString[index] = value
    def get_userParameterBase64(self): return self.userParameterBase64
    def set_userParameterBase64(self, userParameterBase64): self.userParameterBase64 = userParameterBase64
    def add_userParameterBase64(self, value): self.userParameterBase64.append(value)
    def insert_userParameterBase64_at(self, index, value): self.userParameterBase64.insert(index, value)
    def replace_userParameterBase64_at(self, index, value): self.userParameterBase64[index] = value
    def hasContent_(self):
        if (
            self.userParameterLong or
            self.userParameterDouble or
            self.userParameterString or
            self.userParameterBase64
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='userParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='userParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='userParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='userParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userParameterLong_ in self.userParameterLong:
            userParameterLong_.export(outfile, level, namespace_, name_='userParameterLong', pretty_print=pretty_print)
        for userParameterDouble_ in self.userParameterDouble:
            userParameterDouble_.export(outfile, level, namespace_, name_='userParameterDouble', pretty_print=pretty_print)
        for userParameterString_ in self.userParameterString:
            userParameterString_.export(outfile, level, namespace_, name_='userParameterString', pretty_print=pretty_print)
        for userParameterBase64_ in self.userParameterBase64:
            userParameterBase64_.export(outfile, level, namespace_, name_='userParameterBase64', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='userParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('userParameterLong=[\n')
        level += 1
        for userParameterLong_ in self.userParameterLong:
            showIndent(outfile, level)
            outfile.write('model_.userParameterLongType(\n')
            userParameterLong_.exportLiteral(outfile, level, name_='userParameterLongType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParameterDouble=[\n')
        level += 1
        for userParameterDouble_ in self.userParameterDouble:
            showIndent(outfile, level)
            outfile.write('model_.userParameterDoubleType(\n')
            userParameterDouble_.exportLiteral(outfile, level, name_='userParameterDoubleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParameterString=[\n')
        level += 1
        for userParameterString_ in self.userParameterString:
            showIndent(outfile, level)
            outfile.write('model_.userParameterStringType(\n')
            userParameterString_.exportLiteral(outfile, level, name_='userParameterStringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('userParameterBase64=[\n')
        level += 1
        for userParameterBase64_ in self.userParameterBase64:
            showIndent(outfile, level)
            outfile.write('model_.userParameterBase64Type(\n')
            userParameterBase64_.exportLiteral(outfile, level, name_='userParameterBase64Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userParameterLong':
            obj_ = userParameterLongType.factory()
            obj_.build(child_)
            self.userParameterLong.append(obj_)
            obj_.original_tagname_ = 'userParameterLong'
        elif nodeName_ == 'userParameterDouble':
            obj_ = userParameterDoubleType.factory()
            obj_.build(child_)
            self.userParameterDouble.append(obj_)
            obj_.original_tagname_ = 'userParameterDouble'
        elif nodeName_ == 'userParameterString':
            obj_ = userParameterStringType.factory()
            obj_.build(child_)
            self.userParameterString.append(obj_)
            obj_.original_tagname_ = 'userParameterString'
        elif nodeName_ == 'userParameterBase64':
            obj_ = userParameterBase64Type.factory()
            obj_.build(child_)
            self.userParameterBase64.append(obj_)
            obj_.original_tagname_ = 'userParameterBase64'
# end class userParameters


class accelerationFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kspace_encoding_step_1=None, kspace_encoding_step_2=None):
        self.original_tagname_ = None
        self.kspace_encoding_step_1 = kspace_encoding_step_1
        self.kspace_encoding_step_2 = kspace_encoding_step_2
    def factory(*args_, **kwargs_):
        if accelerationFactorType.subclass:
            return accelerationFactorType.subclass(*args_, **kwargs_)
        else:
            return accelerationFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kspace_encoding_step_1(self): return self.kspace_encoding_step_1
    def set_kspace_encoding_step_1(self, kspace_encoding_step_1): self.kspace_encoding_step_1 = kspace_encoding_step_1
    def get_kspace_encoding_step_2(self): return self.kspace_encoding_step_2
    def set_kspace_encoding_step_2(self, kspace_encoding_step_2): self.kspace_encoding_step_2 = kspace_encoding_step_2
    def hasContent_(self):
        if (
            self.kspace_encoding_step_1 is not None or
            self.kspace_encoding_step_2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='accelerationFactorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accelerationFactorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='accelerationFactorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='accelerationFactorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='accelerationFactorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kspace_encoding_step_1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skspace_encoding_step_1>%s</%skspace_encoding_step_1>%s' % (namespace_, self.gds_format_integer(self.kspace_encoding_step_1, input_name='kspace_encoding_step_1'), namespace_, eol_))
        if self.kspace_encoding_step_2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skspace_encoding_step_2>%s</%skspace_encoding_step_2>%s' % (namespace_, self.gds_format_integer(self.kspace_encoding_step_2, input_name='kspace_encoding_step_2'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='accelerationFactorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.kspace_encoding_step_1 is not None:
            showIndent(outfile, level)
            outfile.write('kspace_encoding_step_1=%d,\n' % self.kspace_encoding_step_1)
        if self.kspace_encoding_step_2 is not None:
            showIndent(outfile, level)
            outfile.write('kspace_encoding_step_2=%d,\n' % self.kspace_encoding_step_2)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kspace_encoding_step_1':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'kspace_encoding_step_1')
            self.kspace_encoding_step_1 = ival_
        elif nodeName_ == 'kspace_encoding_step_2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'kspace_encoding_step_2')
            self.kspace_encoding_step_2 = ival_
# end class accelerationFactorType


class parallelImagingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accelerationFactor=None, calibrationMode=None, interleavingDimension=None):
        self.original_tagname_ = None
        self.accelerationFactor = accelerationFactor
        self.calibrationMode = calibrationMode
        self.validate_calibrationModeType(self.calibrationMode)
        self.interleavingDimension = interleavingDimension
        self.validate_interleavingDimensionType(self.interleavingDimension)
    def factory(*args_, **kwargs_):
        if parallelImagingType.subclass:
            return parallelImagingType.subclass(*args_, **kwargs_)
        else:
            return parallelImagingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accelerationFactor(self): return self.accelerationFactor
    def set_accelerationFactor(self, accelerationFactor): self.accelerationFactor = accelerationFactor
    def get_calibrationMode(self): return self.calibrationMode
    def set_calibrationMode(self, calibrationMode): self.calibrationMode = calibrationMode
    def get_interleavingDimension(self): return self.interleavingDimension
    def set_interleavingDimension(self, interleavingDimension): self.interleavingDimension = interleavingDimension
    def validate_calibrationModeType(self, value):
        # Validate type calibrationModeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['embedded', 'interleaved', 'separate', 'external', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on calibrationModeType' % {"value" : value.encode("utf-8")} )
    def validate_interleavingDimensionType(self, value):
        # Validate type interleavingDimensionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['phase', 'repetition', 'contrast', 'average', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on interleavingDimensionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.accelerationFactor is not None or
            self.calibrationMode is not None or
            self.interleavingDimension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='parallelImagingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parallelImagingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='parallelImagingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='parallelImagingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='parallelImagingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accelerationFactor is not None:
            self.accelerationFactor.export(outfile, level, namespace_, name_='accelerationFactor', pretty_print=pretty_print)
        if self.calibrationMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalibrationMode>%s</%scalibrationMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.calibrationMode).encode(ExternalEncoding), input_name='calibrationMode'), namespace_, eol_))
        if self.interleavingDimension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterleavingDimension>%s</%sinterleavingDimension>%s' % (namespace_, self.gds_format_string(quote_xml(self.interleavingDimension).encode(ExternalEncoding), input_name='interleavingDimension'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='parallelImagingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.accelerationFactor is not None:
            showIndent(outfile, level)
            outfile.write('accelerationFactor=model_.accelerationFactorType(\n')
            self.accelerationFactor.exportLiteral(outfile, level, name_='accelerationFactor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibrationMode is not None:
            showIndent(outfile, level)
            outfile.write('calibrationMode=%s,\n' % quote_python(self.calibrationMode).encode(ExternalEncoding))
        if self.interleavingDimension is not None:
            showIndent(outfile, level)
            outfile.write('interleavingDimension=%s,\n' % quote_python(self.interleavingDimension).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accelerationFactor':
            obj_ = accelerationFactorType.factory()
            obj_.build(child_)
            self.accelerationFactor = obj_
            obj_.original_tagname_ = 'accelerationFactor'
        elif nodeName_ == 'calibrationMode':
            calibrationMode_ = child_.text
            calibrationMode_ = self.gds_validate_string(calibrationMode_, node, 'calibrationMode')
            self.calibrationMode = calibrationMode_
            # validate type calibrationModeType
            self.validate_calibrationModeType(self.calibrationMode)
        elif nodeName_ == 'interleavingDimension':
            interleavingDimension_ = child_.text
            interleavingDimension_ = self.gds_validate_string(interleavingDimension_, node, 'interleavingDimension')
            self.interleavingDimension = interleavingDimension_
            # validate type interleavingDimensionType
            self.validate_interleavingDimensionType(self.interleavingDimension)
# end class parallelImagingType


GDSClassesMapping = {
    'parallelImaging': parallelImagingType,
    'set': limitType,
    'experimentalConditions': experimentalConditionsType,
    'accelerationFactor': accelerationFactorType,
    'acquisitionSystemInformation': acquisitionSystemInformationType,
    'userParameterLong': userParameterLongType,
    'sequenceParameters': sequenceParametersType,
    'userParameterDouble': userParameterDoubleType,
    'slice': limitType,
    'reconSpace': encodingSpaceType,
    'studyInformation': studyInformationType,
    'contrast': limitType,
    'userParameterString': userParameterStringType,
    'kspace_encoding_step_1': limitType,
    'kspace_encoding_step_0': limitType,
    'kspace_encoding_step_2': limitType,
    'measurementInformation': measurementInformationType,
    'encodingLimits': encodingLimitsType,
    'phase': limitType,
    'repetition': limitType,
    'segment': limitType,
    'encodedSpace': encodingSpaceType,
    'userParameterBase64': userParameterBase64Type,
    'measurementDependency': measurementDependencyType,
    'subjectInformation': subjectInformationType,
    'trajectoryDescription': trajectoryDescriptionType,
    'coilLabel': coilLabelType,
    'average': limitType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ismrmrdHeader'
        rootClass = ismrmrdHeader
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ismrmrdHeader'
        rootClass = ismrmrdHeader
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ismrmrdHeader'
        rootClass = ismrmrdHeader
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ismrmrdHeader'
        rootClass = ismrmrdHeader
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from schema import *\n\n')
        sys.stdout.write('import schema as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "accelerationFactorType",
    "acquisitionSystemInformationType",
    "coilLabelType",
    "encoding",
    "encodingLimitsType",
    "encodingSpaceType",
    "experimentalConditionsType",
    "fieldOfView_mm",
    "ismrmrdHeader",
    "limitType",
    "matrixSize",
    "measurementDependencyType",
    "measurementInformationType",
    "parallelImagingType",
    "referencedImageSequence",
    "sequenceParametersType",
    "studyInformationType",
    "subjectInformationType",
    "trajectoryDescriptionType",
    "userParameterBase64Type",
    "userParameterDoubleType",
    "userParameterLongType",
    "userParameterStringType",
    "userParameters"
]
